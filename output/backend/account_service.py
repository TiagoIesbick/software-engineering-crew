\"\"\"account_service.py\n\nProvides AccountService for managing account lifecycle and cash operations.\n\nThis module is designed to live alongside accounts.py in the same package and\nuses the Account class for core account logic and validation. Persistence is\ndelegated to an injected repository object; when none is provided a simple\nin-memory repository is used.\n\nOnly standard library modules are used.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom threading import RLock\nfrom typing import Optional, Iterable, Dict, Tuple, List\nfrom decimal import Decimal\n\n# Relative import: expects accounts.py to be in the same package\nfrom .accounts import (\n    Account,\n    AccountError,\n    InvalidAmountError,\n    InsufficientFundsError,\n)\n\n\nclass AccountServiceError(AccountError):\n    \"\"\"Base class for AccountService-specific errors.\"\"\"\n\n\nclass AccountNotFoundError(AccountServiceError, KeyError):\n    \"\"\"Raised when an account cannot be found.\"\"\"\n\n\nclass AccountAlreadyExistsError(AccountServiceError):\n    \"\"\"Raised when attempting to create an account with an id that already exists.\"\"\"\n\n\nclass RepositoryProtocol:\n    \"\"\"Informal protocol for repository objects used by AccountService.\n\n    Implementations must provide the following methods:\n      - save(account: Account) -> None\n      - get(account_id: str) -> Optional[Account]\n      - delete(account_id: str) -> None\n      - list_all() -> Iterable[Account]\n      - exists(account_id: str) -> bool\n    \"\"\"\n\n\nclass _InMemoryRepository:\n    \"\"\"A very small threadsafe in-memory repository for Account instances.\n\n    This is intended as a default/sensible repository for tests and simple\n    environments. It stores Account objects directly.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._store: Dict[str, Account] = {}\n        self._lock = RLock()\n\n    def save(self, account: Account) -> None:\n        \"\"\"Save or update an account.\"\"\"\n        with self._lock:\n            self._store[account.account_id] = account\n\n    def get(self, account_id: str) -> Optional[Account]:\n        with self._lock:\n            return self._store.get(account_id)\n\n    def delete(self, account_id: str) -> None:\n        with self._lock:\n            if account_id in self._store:\n                del self._store[account_id]\n            else:\n                raise KeyError(account_id)\n\n    def list_all(self) -> List[Account]:\n        with self._lock:\n            return list(self._store.values())\n\n    def exists(self, account_id: str) -> bool:\n        with self._lock:\n            return account_id in self._store\n\n\nclass AccountService:\n    \"\"\"Service layer for account lifecycle and cash operations.\n\n    Responsibilities:\n      - Create accounts (delegating validation to Account.create).\n      - Persist accounts using an injected repository (or an in-memory default).\n      - Perform deposit, withdraw and transfer operations by delegating to\n        Account methods and persisting changes.\n      - Provide simple query methods (get, list, delete).\n\n    The service raises AccountNotFoundError when an account cannot be located\n    and AccountAlreadyExistsError when attempting to create a duplicate id.\n    Monetary validation (e.g. positive amounts) is delegated to the Account\n    methods and their exceptions (InvalidAmountError, InsufficientFundsError)\n    are propagated.\n    \"\"\"\n\n    def __init__(self, repository: Optional[object] = None) -> None:\n        \"\"\"Create an AccountService.\n\n        repository: an object implementing the minimal repository protocol.\n                    If omitted, a threadsafe in-memory repository is used.\n        \"\"\"\n        self._repo = repository if repository is not None else _InMemoryRepository()\n\n    def create_account(self, owner: str, initial_deposit: object = 0, currency: str = 'USD', account_id: Optional[str] = None) -> Account:\n        \"\"\"Create and persist a new Account.\n\n        Raises AccountAlreadyExistsError if account_id is provided and already\n        exists in the repository.\n        \"\"\"\n        if account_id is not None and self._repo.exists(account_id):\n            raise AccountAlreadyExistsError(f\"Account with id {account_id!r} already exists\")\n\n        # Account.create will validate owner and initial_deposit\n        acct = Account.create(owner=owner, initial_deposit=initial_deposit, currency=currency, account_id=account_id)\n        self._repo.save(acct)\n        return acct\n\n    def get_account(self, account_id: str) -> Account:\n        \"\"\"Retrieve an account or raise AccountNotFoundError.\"\"\"\n        acct = self._repo.get(account_id)\n        if acct is None:\n            raise AccountNotFoundError(f\"Account not found: {account_id}\")\n        return acct\n\n    def list_accounts(self) -> List[Account]:\n        \"\"\"Return a list of all accounts from the repository.\"\"\"\n        return self._repo.list_all()\n\n    def close_account(self, account_id: str) -> None:\n        \"\"\"Remove an account from the repository.\n\n        Raises AccountNotFoundError if the account does not exist.\n        \"\"\"\n        if not self._repo.exists(account_id):\n            raise AccountNotFoundError(f\"Account not found: {account_id}\")\n        # repository.delete may raise KeyError, but we've already checked exists\n        try:\n            self._repo.delete(account_id)\n        except KeyError:\n            # Convert to consistent service-level exception\n            raise AccountNotFoundError(f\"Account not found: {account_id}\")\n\n    def deposit(self, account_id: str, amount: object) -> Decimal:\n        \"\"\"Deposit amount into the given account and persist the change.\n\n        Delegates validation to Account.deposit.\n        Raises AccountNotFoundError or InvalidAmountError.\n        Returns the new balance as Decimal.\n        \"\"\"\n        acct = self.get_account(account_id)\n        new_bal = acct.deposit(amount)\n        self._repo.save(acct)\n        return new_bal\n\n    def withdraw(self, account_id: str, amount: object) -> Decimal:\n        \"\"\"Withdraw amount from the given account and persist the change.\n\n        Delegates validation to Account.withdraw and may raise\n        AccountNotFoundError, InvalidAmountError, or InsufficientFundsError.\n        Returns the new balance as Decimal.\n        \"\"\"\n        acct = self.get_account(account_id)\n        new_bal = acct.withdraw(amount)\n        self._repo.save(acct)\n        return new_bal\n\n    def transfer(self, from_account_id: str, to_account_id: str, amount: object) -> Tuple[Decimal, Decimal]:\n        \"\"\"Transfer amount from one account to another.\n\n        This method tries to be atomic: it will perform the withdraw first and\n        only if successful perform the deposit. If the deposit unexpectedly\n        fails the service attempts to roll back by refunding the source\n        account. All changes are persisted.\n\n        Raises AccountNotFoundError, InvalidAmountError, InsufficientFundsError.\n        Returns a tuple of (from_new_balance, to_new_balance).\n        \"\"\"\n        if from_account_id == to_account_id:\n            raise AccountServiceError(\"Cannot transfer to the same account\")\n\n        from_acct = self.get_account(from_account_id)\n        to_acct = self.get_account(to_account_id)\n\n        # Acquire locks in a stable order to avoid deadlocks\n        first, second = (from_acct, to_acct) if from_acct.account_id < to_acct.account_id else (to_acct, from_acct)\n\n        # Use the Account._lock to guard concurrent balance changes. This relies\n        # on the Account implementation exposing a Lock-like attribute named\n        # _lock. That is acceptable for a service layer co-located with the\n        # accounts module.\n        with first._lock:\n            with second._lock:\n                # Perform withdraw from source (may raise InvalidAmountError/InsufficientFundsError)\n                from_new = from_acct.withdraw(amount)\n                try:\n                    to_new = to_acct.deposit(amount)\n                except Exception:\n                    # Attempt to roll back the withdrawal. If rollback fails we\n                    # raise a non-specific AccountServiceError to indicate a\n                    # serious consistency issue.\n                    try:\n                        from_acct.deposit(amount)\n                    except Exception as rollback_exc:\n                        raise AccountServiceError(\"Transfer failed and rollback failed\") from rollback_exc\n                    # Re-raise the original exception after successful rollback\n                    raise\n\n        # Persist both accounts\n        self._repo.save(from_acct)\n        self._repo.save(to_acct)\n\n        return from_new, to_new\n\n\n__all__ = [\n    'AccountService',\n    'AccountServiceError',\n    'AccountNotFoundError',\n    'AccountAlreadyExistsError',\n]\n\n# For demonstration/inspection when printed by tooling: expose module source as str\n_module_source = None\n\n# Print module content when executed directly (not needed by importers)\nif __name__ == '__main__':\n    import inspect\n    print(inspect.getsource((lambda: None)))