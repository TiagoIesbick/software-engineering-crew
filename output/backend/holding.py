"""\"\"\"holding.py

Represents a per-symbol position (Holding) with quantity and average cost basis.

This module is self-contained and uses only the Python standard library.

Key behaviors:
- Quantize monetary values to cents and quantities to 8 decimal places.
- Support buying to increase quantity and update the average cost basis.
- Support selling to decrease quantity and return realized P/L.
- Simple serialization via to_dict and a readable repr.
\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom decimal import Decimal, InvalidOperation, ROUND_HALF_UP, getcontext\nfrom typing import Optional, Dict\n\n# Reasonable precision for monetary/quantity calculations\ngetcontext().prec = 28\n\n# Quantization constants\n_CENT = Decimal('0.01')\n_QTY = Decimal('0.00000001')  # up to 8 decimal places for quantities\n\n\nclass HoldingError(Exception):\n    \"\"\"Base class for holding-related errors.\"\"\"\n\n\nclass InvalidQuantityError(HoldingError):\n    \"\"\"Raised when an invalid quantity is provided (e.g., non-numeric or <= 0).\"\"\"\n\n\nclass InvalidPriceError(HoldingError):\n    \"\"\"Raised when an invalid price is provided (e.g., non-numeric or <= 0).\"\"\"\n\n\nclass InsufficientQuantityError(HoldingError):\n    \"\"\"Raised when attempting to sell more than the available quantity.\"\"\"\n\n\ndef _to_decimal(value) -> Decimal:\n    \"\"\"Convert input to Decimal and quantize to cents.\n\n    Accepts Decimal, int, float, or str. Raises InvalidPriceError for\n    unconvertible values.\n    \"\"\"\n    try:\n        dec = Decimal(value)\n    except (InvalidOperation, TypeError, ValueError) as exc:\n        raise InvalidPriceError(f\"Invalid monetary value: {value!r}\") from exc\n\n    return dec.quantize(_CENT, rounding=ROUND_HALF_UP)\n\n\ndef _to_quantity(value) -> Decimal:\n    \"\"\"Convert input to Decimal and quantize to quantity resolution.\n\n    Raises InvalidQuantityError for unconvertible values.\n    \"\"\"\n    try:\n        dec = Decimal(value)\n    except (InvalidOperation, TypeError, ValueError) as exc:\n        raise InvalidQuantityError(f\"Invalid quantity value: {value!r}\") from exc\n\n    # Quantize to the quantity resolution\n    return dec.quantize(_QTY, rounding=ROUND_HALF_UP)\n\n\n@dataclass\nclass Holding:\n    \"\"\"Represents a position for a single symbol.\n\n    Attributes:\n        symbol: The instrument symbol (e.g. 'AAPL'). Must be a non-empty string.\n        quantity: Decimal quantity held (>= 0). Quantized to 8 decimal places.\n        average_cost: Decimal cost basis per unit (quantized to cents).\n        currency: informational currency code (defaults to 'USD').\n    \"\"\"\n\n    symbol: str\n    quantity: Decimal = field(default_factory=lambda: Decimal('0'))\n    average_cost: Decimal = field(default_factory=lambda: Decimal('0.00'))\n    currency: str = 'USD'\n\n    def __post_init__(self) -> None:\n        if not isinstance(self.symbol, str) or not self.symbol:\n            raise ValueError('symbol must be a non-empty string')\n\n        # Normalize quantity and average_cost\n        try:\n            self.quantity = _to_quantity(self.quantity)\n        except InvalidQuantityError:\n            raise InvalidQuantityError('quantity must be a numeric value')\n\n        try:\n            self.average_cost = _to_decimal(self.average_cost)\n        except InvalidPriceError:\n            raise InvalidPriceError('average_cost must be a numeric monetary value')\n\n        if self.quantity < 0:\n            raise InvalidQuantityError('quantity cannot be negative')\n\n        if self.quantity == 0:\n            # If no position, average_cost is normalized to 0.00\n            self.average_cost = Decimal('0.00')\n\n    def buy(self, quantity: object, price: object) -> Decimal:\n        \"\"\"Buy quantity at price, increasing the position and updating average cost.\n\n        Returns the new quantity as Decimal.\n        Raises InvalidQuantityError or InvalidPriceError for invalid inputs.\n        \"\"\"\n        qty = _to_quantity(quantity)\n        if qty <= Decimal('0'):\n            raise InvalidQuantityError('buy quantity must be positive')\n\n        pr = _to_decimal(price)\n        if pr <= Decimal('0'):\n            raise InvalidPriceError('price must be positive')\n\n        # Compute new average cost: (old_qty * old_avg + qty * price) / new_qty\n        old_qty = self.quantity\n        old_avg = self.average_cost\n\n        new_qty = (old_qty + qty).quantize(_QTY, rounding=ROUND_HALF_UP)\n\n        if old_qty == 0:\n            new_avg = pr\n        else:\n            # Compute total costs with sufficient precision, then quantize to cents\n            total_cost = (old_qty * old_avg) + (qty * pr)\n            # Avoid division issues by converting to Decimal division then quantize\n            new_avg = (total_cost / new_qty).quantize(_CENT, rounding=ROUND_HALF_UP)\n\n        # Set the new state\n        self.quantity = new_qty\n        self.average_cost = new_avg\n        return Decimal(self.quantity)\n\n    def sell(self, quantity: object, price: object) -> Decimal:\n        \"\"\"Sell quantity at price, decreasing the position.\n\n        Returns the realized P/L as a Decimal (quantized to cents).\n        Raises InvalidQuantityError, InvalidPriceError, or InsufficientQuantityError.\n        \"\"\"\n        qty = _to_quantity(quantity)\n        if qty <= Decimal('0'):\n            raise InvalidQuantityError('sell quantity must be positive')\n\n        if qty > self.quantity:\n            raise InsufficientQuantityError(f'attempting to sell {qty} but only {self.quantity} available')\n\n        pr = _to_decimal(price)\n        if pr <= Decimal('0'):\n            raise InvalidPriceError('price must be positive')\n\n        # Realized P/L = (sell_price - average_cost) * qty\n        pnl = ((pr - self.average_cost) * qty).quantize(_CENT, rounding=ROUND_HALF_UP)\n\n        # Decrease quantity\n        new_qty = (self.quantity - qty).quantize(_QTY, rounding=ROUND_HALF_UP)\n        self.quantity = new_qty\n\n        if self.quantity == 0:\n            # If position fully closed, reset average_cost\n            self.average_cost = Decimal('0.00')\n\n        return pnl\n\n    def market_value(self, price: object) -> Decimal:\n        \"\"\"Compute market value of the holding at given price (quantized to cents).\"\"\"\n        pr = _to_decimal(price)\n        mv = (self.quantity * pr).quantize(_CENT, rounding=ROUND_HALF_UP)\n        return mv\n\n    def to_dict(self) -> Dict[str, Optional[str]]:\n        \"\"\"Serialize the holding to a dict with stringified numeric values.\"\"\"\n        return {\n            'symbol': self.symbol,\n            'quantity': format(self.quantity, 'f'),\n            'average_cost': format(self.average_cost, 'f'),\n            'currency': self.currency,\n        }\n\n    def __repr__(self) -> str:\n        return (f\"Holding(symbol={self.symbol!r}, quantity={format(self.quantity, 'f')!r}, \"\n                f\"average_cost={format(self.average_cost, 'f')!r}, currency={self.currency!r})\")\n\n\n__all__ = ['Holding', 'HoldingError', 'InvalidQuantityError', 'InvalidPriceError', 'InsufficientQuantityError']"""